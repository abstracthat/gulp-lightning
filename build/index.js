// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = function(gulp, options) {
    var axis, bowerFiles, browserSync, browserify, bust, config, del, dirname, downbeat, emailConfig, emailMap, exists, fs, getEmailData, getSiteData, glob, grid, jade, lazypipe, lib, mailChimp, map, markdownTemplate, marked, moment, path, plugins, reload, request, rsync, runSequence, rupture, through, toText, typography, yaml, _;
    plugins = (require('gulp-load-plugins'))();
    lazypipe = require('lazypipe');
    runSequence = (require('run-sequence')).use(gulp);
    browserSync = require('browser-sync');
    reload = browserSync.reload;
    bowerFiles = require('main-bower-files');
    exists = (require('fs')).existsSync;
    browserify = require('browserify');
    through = (require('through2')).obj;
    rsync = (require('rsyncwrapper')).rsync;
    axis = require('axis');
    rupture = require('rupture');
    grid = require('happy-grid');
    downbeat = require('downbeat');
    lib = require('stylus-lightning');
    moment = require('moment');
    fs = require('fs');
    path = require('path');
    del = require('del');
    jade = require('jade');
    _ = require('lodash');
    typography = require('typogr');
    dirname = require('path').dirname;
    yaml = require('yamljs');
    glob = require('globby');
    request = require('request');
    toText = (require('html-to-text')).fromString;
    marked = require('marked');
    marked.setOptions({
      smartypants: true,
      breaks: true
    });
    map = require('./map');
    emailMap = require('./email-map');
    config = {
      server: '',
      site: {
        source: 'site',
        development: 'site/.development',
        production: 'site/.production',
        styles: 'site/styles',
        scripts: 'site/scripts',
        content: 'site/content',
        templates: 'site/templates',
        images: 'site/images',
        fonts: 'site/fonts',
        root: 'site/root'
      },
      email: {
        source: 'email',
        build: 'email/.build',
        content: 'email/content',
        campaigns: 'email/content/campaigns',
        autoresponders: 'email/content/autoresponders',
        rss: 'email/content/rss',
        splitTests: 'email/content/split-tests',
        images: 'email/images',
        styles: 'email/styles',
        templates: 'email/templates'
      }
    };
    config = _.merge(config, options);
    gulp.task('map', function(done) {
      return map(config, done);
    });
    gulp.task('jade', function() {
      return gulp.src(["" + config.site.content + "/**/*.{jade,md}", "!" + config.site.content + "/_includes/**/*"]).pipe(plugins.plumber()).pipe(plugins.frontMatter({
        property: 'data'
      })).pipe(getSiteData()).pipe(plugins["if"]('*.jade', plugins.jade({
        pretty: true
      }))).pipe(plugins["if"]('*.md', markdownTemplate())).pipe(plugins.prettyUrl()).pipe(gulp.dest(config.site.development));
    });
    getSiteData = lazypipe().pipe(plugins.data, function(file) {
      var data, date, meta, metaDataFile, site, _i, _len, _ref;
      site = require("" + (process.cwd()) + "/" + config.site.source + "/site.json");
      file.data.url = (file.path.slice((file.path.indexOf(config.site.content)) + config.site.content.length)).replace(/((\/)index)?(\.jade$|.\md$)/, '/');
      file.data.collection = (dirname(file.data.url)) + '/';
      if (file.data.url === '/') {
        metaDataFile = "./" + config.site.content + file.data.collection + "index.yml";
      } else {
        metaDataFile = "./" + config.site.content + (file.data.url.slice(0, -1)) + ".yml";
      }
      if (exists(metaDataFile)) {
        file.data = _.merge(yaml.load(metaDataFile), file.data);
      }
      date = new Date(file.data.date);
      if (file.data.date) {
        file.data.datetime = moment(date).format();
        file.data.date = moment(date).format('MMMM Do, YYYY');
      }
      if ((path.extname(file.path)) === '.md') {
        if (!file.data.layout) {
          file.data.layout = 'post';
        }
        file.data.layout = "" + config.site.templates + "/" + file.data.layout + ".jade";
        file.data.pretty = true;
      }
      _ref = ['title', 'description', 'og_title', 'og_description', 'twitter_title', 'twitter_description'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        meta = _ref[_i];
        if (file.data[meta]) {
          file.data[meta] = typography(file.data[meta]).chain().smartypants().value();
        }
      }
      file.data._ = require('lodash');
      file.data.typography = (require('typogr')).typogrify;
      return data = _.extend({}, site, file.data);
    });
    markdownTemplate = lazypipe().pipe(plugins.markdown).pipe(plugins.layout, function(file) {
      return file.data;
    });
    gulp.task('feed', function() {
      var site;
      site = require("" + (process.cwd()) + "/" + config.site.source + "/site.json");
      return gulp.src("" + (process.cwd()) + "/node_modules/gulp-lightning/templates/{atom,rss}.jade").pipe(plugins.jade({
        locals: site,
        jade: jade
      })).pipe(plugins.rename({
        dirname: '',
        extname: '.xml'
      })).pipe(gulp.dest(config.site.development));
    });
    gulp.task('stylus', function() {
      return gulp.src("" + config.site.styles + "/main.styl").pipe(plugins.plumber()).pipe(plugins.sourcemaps.init()).pipe(plugins.stylus({
        use: [
          rupture({
            implicit: false
          }), axis({
            implicit: false
          }), lib(), grid(), downbeat()
        ]
      })).pipe(plugins.autoprefixer({
        browsers: ['> 1%', 'last 2 versions', 'Firefox ESR', 'Opera 12.1', 'Explorer >= 9']
      })).pipe(plugins.sourcemaps.write()).pipe(gulp.dest(config.site.development)).pipe(reload({
        stream: true
      }));
    });
    gulp.task('coffee', function() {
      return gulp.src("" + config.site.scripts + "/**/*.coffee").pipe(plugins.plumber()).pipe(plugins.sourcemaps.init()).pipe(plugins.coffee()).on('error', plugins.util.log).pipe(plugins.sourcemaps.write()).pipe(gulp.dest(config.site.development));
    });
    gulp.task('js', ['coffee', 'bower'], function() {
      return gulp.src("" + config.site.development + "/main.js").pipe(plugins.plumber()).pipe(through(function(file, enc, next) {
        return (browserify(file.path)).bundle(function(err, res) {
          file.contents = res;
          return next(null, file);
        });
      })).pipe(gulp.dest(config.site.development));
    });
    gulp.task('installBower', function() {
      return gulp.src('bower.json').pipe(plugins.install());
    });
    gulp.task('bower', ['installBower'], function() {
      if (exists('./bower_components')) {
        return gulp.src(bowerFiles()).pipe(gulp.dest("" + config.site.development + "/lib"));
      }
    });
    gulp.task('compile', ['js', 'jade', 'feed', 'stylus']);
    gulp.task('optimize', function() {
      var assets;
      assets = plugins.useref.assets({
        searchPath: config.site.development
      });
      return gulp.src("" + config.site.development + "/**/*.html").pipe(assets).pipe(plugins["if"]('*.css', plugins.csso())).pipe(plugins["if"]('*.js', plugins.uglify())).pipe(gulp.dest(config.site.production)).pipe(assets.restore()).pipe(plugins.useref()).pipe(plugins["if"]('*.html', plugins.minifyHtml())).pipe(gulp.dest(config.site.production));
    });
    bust = new plugins.cachebust();
    gulp.task('cacheresources', function() {
      gulp.src("" + config.site.production + "/**/*.css").pipe(bust.resources()).pipe(gulp.dest(config.site.production));
      return gulp.src("" + config.site.production + "/**/*.js").pipe(bust.resources()).pipe(gulp.dest(config.site.production));
    });
    gulp.task('cacheref', ['cacheresources'], function() {
      return gulp.src("" + config.site.production + "/**/*.html").pipe(bust.references()).pipe(gulp.dest(config.site.production));
    });
    gulp.task('cachebust', ['cacheref'], function(done) {
      return del(["" + config.site.production + "/script.min.js", "" + config.site.production + "/style.min.css"], done());
    });
    gulp.task('images', function() {
      return gulp.src("" + config.site.images + "/*").pipe(plugins.plumber()).pipe(plugins.cache(plugins.imagemin({
        progressive: true,
        interlaced: true
      }))).pipe(gulp.dest("" + config.site.production + "/images"));
    });
    gulp.task('move', function() {
      return gulp.src(["" + config.site.fonts + "/**/*", "" + config.site.development + "/*.xml", "" + config.site.root + "/**/*", "!" + config.site.source + "/**/.keep"], {
        dot: true
      }).pipe(gulp.dest(config.site.production));
    });
    gulp.task('clear', function(done) {
      return plugins.cache.clearAll(done);
    });
    gulp.task('clean', ['clear'], function(done) {
      return del([config.site.development, config.site.production, "" + config.site.source + "/site.json", config.email.build, "" + config.email.source + "/email.json"], done());
    });
    gulp.task('browser', function() {
      browserSync.init({
        notify: false,
        server: {
          baseDir: [config.site.development, config.site.source]
        }
      });
      gulp.watch("{" + config.site.content + "," + config.site.templates + "}/**/*", ['jade', reload]);
      gulp.watch("" + config.site.styles + "/**/*", ['stylus']);
      gulp.watch("" + config.site.scripts + "/**/*", ['js', reload]);
      return gulp.watch("" + config.site.images + "/**/*", reload);
    });
    gulp.task('previewBrowser', function() {
      return browserSync({
        server: {
          baseDir: config.site.production
        }
      });
    });
    gulp.task('rsync', function(done) {
      return rsync({
        ssh: true,
        src: "" + config.site.production + "/",
        dest: config.server,
        recursive: true,
        "delete": true,
        exclude: ['images/email'],
        args: ['--verbose']
      }, function(erro, stdout, stderr, cmd) {
        plugins.util.log(stdout);
        return done();
      });
    });
    gulp.task('email:map', function(done) {
      return emailMap(config, done);
    });
    gulp.task('email:stylus', function() {
      return gulp.src("" + config.email.styles + "/main.styl").pipe(plugins.stylus()).pipe(gulp.dest(config.email.build));
    });
    getEmailData = lazypipe().pipe(plugins.data, function(file) {
      var data, defaultEmailData, dir, email, isAutoresponder, isCampaign, isRSS, isSplitTest, key, locals, metaDataFile, site, slug, value, _base, _base1, _ref;
      site = yaml.load("./" + config.site.source + "/site.yml");
      email = require("" + (process.cwd()) + "/" + config.email.source + "/email.json");
      locals = _.extend(email, site);
      defaultEmailData = {
        autoresponders: yaml.load("./" + config.email.autoresponders + "/_default.yml"),
        campaigns: yaml.load("./" + config.email.campaigns + "/_default.yml"),
        rss: yaml.load("./" + config.email.rss + "/_default.yml"),
        splitTest: yaml.load("./" + config.email.splitTests + "/_default.yml")
      };
      file.data = {};
      file.mailChimp = {
        type: '',
        options: {},
        type_opts: {},
        content: {
          html: '',
          text: ''
        }
      };
      slug = path.basename(file.path, path.extname(file.path));
      dir = path.dirname(file.path);
      isCampaign = dir.match(config.email.campaigns);
      isAutoresponder = dir.match(config.email.autoresponders);
      isRSS = dir.match(config.email.rss);
      isSplitTest = dir.match(config.email.splitTests);
      if (isCampaign) {
        file.data.collection = 'campaigns';
        file.mailChimp = _.merge(file.mailChimp, defaultEmailData.campaigns);
      }
      if (isAutoresponder) {
        file.data.directory = dir.slice((dir.lastIndexOf('/')) + 1);
        file.data.collection = "autoresponders/" + file.data.directory;
        file.mailChimp = _.merge(file.mailChimp, defaultEmailData.autoresponders);
      }
      if (isRSS) {
        file.data.collection = 'rss';
        file.mailChimp = _.merge(file.mailChimp, defaultEmailData.rss);
        file.mailChimp.type_opts.rss.url = "" + locals.site.url + "/rss.xml";
      }
      if (isSplitTest) {
        file.data.collection = 'split-tests';
        file.mailChimp = _.merge(file.mailChimp, defaultEmailData.splitTest);
        if (file.attributes.subject_a) {
          file.mailChimp.type_opts.absplit.subject_a = file.attributes.subject_a;
        }
        if (file.attributes.subject_b) {
          file.mailChimp.type_opts.absplit.subject_b = file.attributes.subject_b;
        }
      }
      metaDataFile = "./" + config.email.content + "/" + file.data.collection + "/" + slug + ".yml";
      if (exists(metaDataFile)) {
        file.mailChimp = _.merge(file.mailChimp, yaml.load(metaDataFile));
      }
      if (!file.mailChimp.options.folder_id) {
        if (file.data.collection.match('autoresponders')) {
          file.mailChimp.options.folder_id = locals.folders.autoresponders;
        } else {
          file.mailChimp.options.folder_id = locals.folders.campaigns;
        }
      }
      file.mailChimp.options.title = "" + file.data.collection + "/" + slug;
      if (file.mailChimp.subject) {
        file.mailChimp.options.subject = file.mailChimp.subject;
      }
      if (file.attributes.subject) {
        file.mailChimp.options.subject = file.attributes.subject;
      }
      if (!locals.author.email) {
        console.error('You need to add an email address to site.yml');
      }
      file.mailChimp.options.from_email = locals.author.email;
      file.mailChimp.options.from_name = locals.site.name;
      if ((_base = file.attributes).list == null) {
        _base.list = 'default';
      }
      file.mailChimp.options.list_id = locals.lists[file.attributes.list];
      delete file.attributes.list;
      if ((_base1 = file.data).layout == null) {
        _base1.layout = file.mailChimp.layout;
      }
      _ref = file.attributes;
      for (key in _ref) {
        value = _ref[key];
        file.data[key] = value;
      }
      if ((path.extname(file.path)) === '.md') {
        file.data.layout = "" + config.email.templates + "/" + file.data.layout + ".jade";
        file.data.pretty = true;
      }
      return data = _.extend(locals, file.data);
    });
    gulp.task('email:index', ['email:stylus', 'email:map'], function() {
      return gulp.src(["" + config.email.templates + "/index.jade"]).pipe(plugins.plumber()).pipe(plugins.jade({
        pretty: true,
        locals: require("" + (process.cwd()) + "/" + config.email.source + "/email.json")
      })).pipe(gulp.dest(config.email.build));
    });
    gulp.task('email:compile', ['email:index'], function() {
      var site;
      site = yaml.load("./" + config.site.source + "/site.yml");
      return gulp.src(["" + config.email.content + "/**/*.{jade,md}", "" + config.email.content + "/_includes/**/*"]).pipe(plugins.plumber()).pipe(plugins.frontMatter({
        property: 'attributes'
      })).pipe(getEmailData()).pipe(plugins["if"]('*.jade', plugins.jade({
        pretty: true
      }))).pipe(plugins["if"]('*.md', markdownTemplate())).pipe(gulp.dest(config.email.build)).pipe(plugins.assetpaths({
        newDomain: site.site.url.replace(/http(s)?:/, ''),
        oldDomain: site.site.url.replace(/http(s)?:/, ''),
        docRoot: '/',
        filetypes: ['jpg', 'jpeg', 'png', 'ico', 'gif']
      })).pipe(gulp.dest("" + config.email.build + "/tmp")).pipe(plugins.data(function(file) {
        file.mailChimp.content.html = fs.readFileSync("./" + config.email.build + "/tmp/" + file.mailChimp.options.title + ".html", 'utf-8');
        file.mailChimp.content.text = toText(file.mailChimp.content.html);
        return fs.writeFileSync("./" + config.email.build + "/" + file.mailChimp.options.title + ".json", JSON.stringify(file.mailChimp));
      }));
    });
    gulp.task('email:paths', function() {
      var site;
      site = yaml.load("./" + config.site.source + "/site.yml");
      return gulp.src("" + config.email.build + "/**/*.html").pipe(plugins.assetpaths({
        newDomain: site.site.url.replace(/http(s)?:/, ''),
        oldDomain: site.site.url.replace(/http(s)?:/, ''),
        docRoot: '/',
        filetypes: ['jpg', 'jpeg', 'png', 'ico', 'gif']
      })).pipe(gulp.dest(config.email.build));
    });
    gulp.task('email:inline', ['email:compile'], function() {
      return gulp.src("" + config.email.build + "/**/*.html").pipe(plugins.inlineSource()).pipe(plugins.inlineCss({
        preserveMediaQueries: true,
        applyLinkTags: false,
        removeLinkTags: false
      })).pipe(gulp.dest(config.email.build));
    });
    gulp.task('email:images', function() {
      return gulp.src("" + config.email.images + "/*").pipe(plugins.plumber()).pipe(plugins.cache(plugins.imagemin({
        progressive: true,
        interlaced: true
      }))).pipe(gulp.dest("" + config.email.build + "/images"));
    });
    gulp.task('email:deploy', function(done) {
      return rsync({
        ssh: true,
        src: "" + config.email.build + "/images/",
        "delete": true,
        dest: "" + config.server + "/images/email",
        recursive: true,
        args: ['--verbose']
      }, function(erro, stdout, stderr, cmd) {
        plugins.util.log(stdout);
        return done();
      });
    });
    gulp.task('email:browser', function() {
      browserSync.init({
        notify: false,
        server: {
          baseDir: config.email.build
        }
      });
      gulp.watch(["" + config.email.styles + "/**/*", "" + config.email.templates + "/**/*", "" + config.email.content + "/**/*", "" + config.email.images + "/**/*"], ['email:reload']);
      return gulp.watch("" + config.email.images + "/**/*", reload);
    });
    gulp.task('email:reload', ['email:inline', 'email:images'], function() {
      return reload();
    });
    gulp.task('email', function() {
      return runSequence('email:reload', 'email:browser');
    });
    mailChimp = {
      body: {}
    };
    emailConfig = {};
    gulp.task('mailchimp:config', function() {
      var secrets;
      emailConfig = yaml.load("" + config.email.source + "/email.yml");
      if (exists('./secrets.yml')) {
        secrets = yaml.load('./secrets.yml');
      } else {
        console.error('Error: You need to setup a secrets file\nmv secrets-copy.yml secrets.yml');
      }
      return mailChimp = {
        baseUrl: "https://" + emailConfig.datacenter + ".api.mailchimp.com/2.0/",
        method: 'POST',
        json: true,
        body: {
          apikey: secrets.mailChimpAPIKey
        }
      };
    });
    gulp.task('mailchimp:lists', ['mailchimp:config'], function() {
      mailChimp.url = 'lists/list';
      return request(mailChimp, function(err, message, res) {
        var list, _i, _len, _ref, _results;
        console.log('Your Lists (name: id)...');
        _ref = res.data;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          list = _ref[_i];
          _results.push(console.log("" + list.name + ": " + list.id));
        }
        return _results;
      });
    });
    gulp.task('mailchimp:segments', ['mailchimp:config'], function() {
      var list, listID, _ref, _results;
      mailChimp.url = 'lists/segments';
      _ref = emailConfig.lists;
      _results = [];
      for (list in _ref) {
        listID = _ref[list];
        mailChimp.body.id = listID;
        _results.push(request(mailChimp, function(err, message, res) {
          var segment, _i, _j, _len, _len1, _ref1, _ref2, _results1;
          if (res["static"].length) {
            console.log("Static Segments for " + list + " (ID Name)");
            _ref1 = res["static"];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              segment = _ref1[_i];
              console.log("" + segment.name + ": " + segment.id);
            }
          }
          if (res.saved.length) {
            console.log("Saved Segments for " + list + " (ID Name)");
            _ref2 = res.saved;
            _results1 = [];
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              segment = _ref2[_j];
              _results1.push(console.log("" + segment.name + ": " + segment.id));
            }
            return _results1;
          } else {
            return console.log("No Segments for " + list);
          }
        }));
      }
      return _results;
    });
    gulp.task('mailchimp:campaign_folders', ['mailchimp:config'], function() {
      mailChimp.url = 'folders/list';
      mailChimp.body.type = 'campaign';
      return request(mailChimp, function(err, message, res) {
        var folder, _i, _len, _results;
        console.log('Campaign Folders:');
        _results = [];
        for (_i = 0, _len = res.length; _i < _len; _i++) {
          folder = res[_i];
          _results.push(console.log("" + folder.name + ", " + folder.folder_id));
        }
        return _results;
      });
    });
    gulp.task('mailchimp:autoresponder_folders', ['mailchimp:config'], function() {
      mailChimp.url = 'folders/list';
      mailChimp.body.type = 'autoresponder';
      return request(mailChimp, function(err, message, res) {
        var folder, _i, _len, _results;
        console.log('Autoresponder Folders:');
        _results = [];
        for (_i = 0, _len = res.length; _i < _len; _i++) {
          folder = res[_i];
          _results.push(console.log("" + folder.name + ", " + folder.folder_id));
        }
        return _results;
      });
    });
    gulp.task('mailchimp:folders', ['mailchimp:campaign_folders', 'mailchimp:autoresponder_folders']);
    gulp.task('mailchimp:vars', ['mailchimp:config'], function() {
      mailChimp.url = 'lists/merge-vars';
      mailChimp.body.id = emailConfig.lists;
      return request(mailChimp, function(err, message, res) {
        var list, mergeVar, _i, _len, _ref, _results;
        _ref = res.data;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          list = _ref[_i];
          console.log("\nThe list, " + list.name + ", with id, " + list.id + " has the following merge vars:");
          _results.push((function() {
            var _j, _len1, _ref1, _results1;
            _ref1 = list.merge_vars;
            _results1 = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              mergeVar = _ref1[_j];
              _results1.push(console.log("" + mergeVar.name + ", " + mergeVar.tag));
            }
            return _results1;
          })());
        }
        return _results;
      });
    });
    gulp.task('mailchimp:autoresponders', ['mailchimp:config'], function() {
      mailChimp.url = 'automations/list';
      return request(mailChimp, function(err, message, res) {
        return console.log(res.data);
      });
    });
    gulp.task('mailchimp:campaigns', ['mailchimp:config'], function() {
      mailChimp.url = 'campaigns/list';
      return request(mailChimp, function(err, message, res) {
        var campaign, _i, _len, _ref, _results;
        _ref = res.data;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          campaign = _ref[_i];
          _results.push(console.log(campaign));
        }
        return _results;
      });
    });
    gulp.task('mailchimp:campaigns', ['mailchimp:config'], function(done) {
      mailChimp.url = 'campaigns/create';
      return glob("" + config.email.build + "/**/*.json", {
        nodir: true
      }, function(err, files) {
        var campaign, collection, file, fileIndex, found, log, newFile, newFiles, slug, title, _i, _j, _k, _len, _len1, _len2, _results;
        newFiles = [];
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          if (exists("" + (process.cwd()) + "/" + config.email.source + "/mailchimpLog.json")) {
            log = require("" + (process.cwd()) + "/" + config.email.source + "/mailchimpLog.json");
          } else {
            log = [];
          }
          fileIndex = (file.indexOf("" + config.email.build + "/")) + ("" + config.email.build + "/").length;
          collection = path.dirname(file.slice(fileIndex));
          slug = path.basename(file, '.json');
          title = "" + collection + "/" + slug;
          found = false;
          if (log) {
            for (_j = 0, _len1 = log.length; _j < _len1; _j++) {
              campaign = log[_j];
              if (title === campaign.title) {
                found = true;
              }
            }
          }
          if (!found) {
            newFiles.push(file);
          }
        }
        if (!newFiles.length) {
          console.log('All campaigns are already synced with MailChimp');
        }
        _results = [];
        for (_k = 0, _len2 = newFiles.length; _k < _len2; _k++) {
          newFile = newFiles[_k];
          mailChimp.body = _.merge(mailChimp.body, require("" + (process.cwd()) + "/" + newFile));
          _results.push(request(mailChimp, function(err, message, res) {
            var key, pro, value, _results1;
            pro = newFile;
            if (res.id) {
              log.push(res);
              fs.writeFileSync("./" + config.email.source + "/mailChimpLog.json", "" + (JSON.stringify(log)));
              return console.log("Check and activate this campaign in Mailchimp:\nhttps://" + emailConfig.datacenter + ".admin.mailchimp.com/campaigns/wizard/confirm?id=" + res.web_id);
            } else {
              _results1 = [];
              for (key in res) {
                value = res[key];
                _results1.push(console.error("" + key + ": " + value));
              }
              return _results1;
            }
          }));
        }
        return _results;
      });
    });
    gulp.task('mailchimp', ['email:deploy', 'email:inline', 'mailchimp:campaigns']);
    gulp.task('develop', function(done) {
      return runSequence('map', 'compile', 'browser', done);
    });
    gulp.task('default', ['develop']);
    gulp.task('site', ['develop']);
    gulp.task('build', function(done) {
      return runSequence('clean', 'map', 'compile', ['optimize', 'move', 'images'], 'cachebust', done);
    });
    gulp.task('preview', function(done) {
      return runSequence('build', 'previewBrowser', done);
    });
    return gulp.task('deploy', ['build'], function(done) {
      return runSequence('rsync', done);
    });
  };

}).call(this);
